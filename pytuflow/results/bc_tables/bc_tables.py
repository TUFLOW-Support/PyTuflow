import re
from pathlib import Path
from typing import Union

import pandas as pd

from .bc_tables_boundary import Boundary
from ..abc.time_series_result import TimeSeriesResult
from pytuflow.types import PathLike, TimeLike
from ..iterator_util import Iterator


class BCTables(TimeSeriesResult):
    """Class for handling 2d_bc_tables_check.csv and 1d_bc_tables_check.csv"""

    def __init__(self, fpath: PathLike) -> None:
        # docstring inherited
        #: Boundary: Boundary object
        self.boundary = None
        super().__init__(fpath)
        self.sim_id = re.sub(r'_[12]d_bc_tables_check', '', self.fpath.stem)

    def __repr__(self) -> str:
        if hasattr(self, 'fpath') and self.fpath:
            return f'<BCTables: {self.fpath.stem}>'
        return '<BCTables>'

    @staticmethod
    def looks_like_self(fpath: Path) -> bool:
        # docstring inherited
        try:
            if not re.findall(r'_[12]d_bc_tables_check$', fpath.stem):
                return False
            with fpath.open() as f:
                line = f.readline()
                if not re.findall(r'^"?Generated by', line):
                    return False
        except Exception as e:
            return False
        return True

    def looks_empty(self, fpath: Path) -> bool:
        # docstring inherited
        try:
            with fpath.open() as f:
                for _ in range(3):
                    line = f.readline()
                if not re.findall(r'^BC\d{6}', line):
                    return True
        except Exception:
            return True
        return False

    def load(self) -> None:
        # docstring inherited
        self.boundary = Boundary(self.fpath)
        if self.boundary.units:
            self.units = self.boundary.units

    def init_iterator(self, *args) -> Iterator:
        # docstring inherited
        if args:
            return Iterator(*args)
        return Iterator(self.boundary)

    def result_types(self, id: Union[str, list[str]] = '', domain: str = '') -> list[str]:
        # docstring inherited
        id = self._correct_id(id)  # need to convert cross-section names to their ids
        result_types = super().result_types(id, domain)
        return result_types

    def boundary_ids(self, boundary_type: Union[str, list[str]] = '') -> list[str]:
        """Return the ids of the boundary type(s) specified.

        :code:`boundary_ids()` is equivalent to using '[1/2]d cross_section' as the domain in
        :meth:`ids() <pytuflow.results.BcTables.ids>` (domain = 1d or 2d depending on whether bc_tables is a
        1d or 2d check file).

        Parameters
        ----------
        boundary_type : str or list[str], optional
            The boundary type can be a single value or a list of values.
            If no boundary type is provided, all result types will be assumed to be all available.

        Returns
        -------
        list[str]
            List of boundary ids.
        """
        if self.boundary:
            if not boundary_type:
                return self.boundary.ids(None)
            return self.ids(boundary_type, f'{self.boundary.domain} boundary')
        return []

    def boundary_types(self, id: Union[str, list[str]] = '') -> list[str]:
        """Return the boundary types of the specified ID(s).

        :code:`boundary_types()` is equivalent to using '[1/2]d cross_section' as the domain in
        :meth:`result_types() <pytuflow.results.BcTables.result_types>`
        (domain = 1d or 2d depending on whether bc_tables is a 1d or 2d check file).

        Parameters
        ----------
        id : str or list[str], optional
            The ID can be a single value or a list of values.
            If no ID is provided, all boundary types will be assumed to be all available.

        Returns
        -------
        list[str]
            List of boundary types.
        """
        if self.boundary:
            if not id:
                return self.boundary.result_types(None)
            return self.ids(id, f'{self.boundary.domain} boundary')
        return []

    def time_series(self,
                    id: Union[str, list[str]],
                    result_type: Union[str, list[str]],
                    domain: str = None,
                    use_common_index: bool = True
                    ) -> pd.DataFrame:
        # docstring inherited
        if not isinstance(id, list):
            id = [id] if id else []
        if not id:
            id = self.boundary_ids(None)
        id_ = id.copy()
        id = self._correct_id(id)
        correct_df_header = id_ != id
        df = super().time_series(id, result_type, domain, use_common_index)
        if correct_df_header:  # convert cross-section ids (e.g. 'XS00001') back to name (e.g. '1d_xs_C109')
            ids = [list(x) for x in df.columns.values.tolist()]
            for bcid in ids:
                name = self.boundary.bcid2name(bcid[2])
                if name in id_:
                    bcid[2] = name
            df.columns = pd.MultiIndex.from_tuples(ids, names=df.columns.names)

        return df

    def long_plot(self,
                  ids: Union[str, list[str]],
                  result_type: Union[str, list[str]],
                  time: TimeLike
                  ) -> pd.DataFrame:
        """Not implemented for BCTables."""
        raise NotImplementedError('long_plot not available for BCTables.')

    def maximum(self, id: Union[str, list[str]], result_type: Union[str, list[str]], domain: str = '') -> pd.DataFrame:
        """Not implemented for HydTables."""
        raise NotImplementedError('maximum not available for HydTables.')

    def _correct_id(self, id: Union[str, list[str]] = '') -> list[str]:
        """Convert cross-section names to their ids as they are stored in the 1d_ta_tables_check.csv file."""
        if not id:
            return []
        if not isinstance(id, list):
            id = [id]
        for i, id_ in enumerate(id):
            if id_.lower() in [x.lower() for x in self.boundary.ids(None)]:
                id[i] = self.boundary.name2bcid(id_)
        return id
