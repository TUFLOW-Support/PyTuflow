import re
from pathlib import Path
from typing import TextIO

import pandas as pd

from .bc_tables_time_series import BCTablesTimeSeries
from .boudary_type import BoundaryType
from ..abc.time_series_result_item import TimeSeriesResultItem
from ..types import PathLike


class BCTablesResultItem(TimeSeriesResultItem):

    def __init__(self, fpath: PathLike) -> None:
        self.tcf = None
        self.units = ''
        self._bndry = []
        super().__init__(fpath)

    def load(self) -> None:
        with self.fpath.open() as f:
            for line in f:
                if line.startswith('Generated by'):
                    self.tcf = self._extract_tcf(line)
                elif re.findall(r'^"?BC\d{6}:\s', line):
                    self.load_time_series(line, f)

        self.name = self.fpath.stem
        if re.findall(r'_1d_bc_tables_check', self.fpath.stem):
            self.domain = '1d'
        elif re.findall(r'_2d_bc_tables_check', self.fpath.stem):
            self.domain = '2d'
        self.domain_2 = 'boundary'

        a = [(x.id, x.name, x.type) for x in self._bndry]
        self.df = pd.DataFrame(a, columns=['ID', 'Name', 'Type'])
        self.df.set_index('ID', inplace=True)

    def load_time_series(self, line: str, fo: TextIO) -> None:
        bndry = BoundaryType(line)
        if not bndry.valid:
            return
        bndry.read(fo)
        self._bndry.append(bndry)
        if bndry.type not in self.time_series:
            self.time_series[bndry.type] = BCTablesTimeSeries()
        self.time_series[bndry.type].append(bndry)
        if not self.units:
            self.units = bndry.units

    def conv_result_type_name(self, result_type: str) -> str:
        return result_type

    def bcid2name(self, bcid: str) -> str:
        if bcid not in self.df.index:
            return bcid
        return self.df.loc[bcid, 'Name']

    def name2bcid(self, name: str) -> str:
        if name not in self.df['Name'].tolist():
            return name
        return self.df[self.df['Name'] == name].index[0]

    def ids(self, result_type: str) -> list[str]:
        if self.df is None:
            return []
        if not result_type:
            return self.df['Name'].tolist()
        if result_type in self.time_series:
            return [x for x in self.time_series[result_type].df.columns.tolist() if x not in self.time_series[result_type].empty_results]
        return []

    def result_types(self, id: str) -> list[str]:
        if not self.time_series:
            return []
        if not id:
            return list(self.time_series.keys())
        result_types = []
        for result_type, ts in self.time_series.items():
            ids = ts.df.columns.tolist()
            ids.extend([self.name2bcid(x) for x in ids if self.name2bcid(x)])
            if result_type not in result_types and id in ids:
                result_types.append(result_type)
        return result_types

    def _extract_tcf(self, line: str) -> PathLike:
        tcf = re.findall(r'".*"', line)
        if tcf:
            tcf = tcf[0].strip('"')
            return Path(tcf)
